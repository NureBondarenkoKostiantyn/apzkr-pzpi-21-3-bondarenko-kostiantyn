Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет  комп’ютерних наук

Кафедра програмної інженерії


КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з дисципліни “Архітектура програмного забезпечення”
Тема роботи: “Програмна система для моніторингу здоров'я та фізичних показників членів спортивної команди”

Виконав:
Студент гр. ПЗПІ-21-3 			                                            Бондаренко К.Т.

Керівник роботи:									
Доц. каф. ПІ                                                                                    Лещинська І. О.

Роботу захищено з оцінкою

Комісія:
Ст. викл. каф. ПІ                                                                               Сокорчук І. П.
Доц. каф. ПІ								 Лещинський В. О.
Доц. каф. ПІ								     Лещинська І. О.


Харків 2024
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

Факультет: комп’ютерних наук. Кафедра: програмної інженерії
Спеціальність: 121-Інженерія програмного забезпечення
Курс: 3. Семестр: 6
Навчальна дисципліна: Архітектура програмного забезпечення


ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

Бондаренку Костянтину Тарасовичу
1 Тема проекту: “Програмна система для моніторингу здоров'я та фізичних показників членів спортивної команди” 
2 Термін узгодження завдання курсової роботи:  11 березня 2024 р.
3 Термін здачі студентом закінченої роботи: 16 червня 2024 р.
4 Вихідні дані до проекту:
Вимоги до програмної системи, предметна область, методичні вказівки до виконання курсової роботи.
5 Зміст пояснювальної записки:
	Вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки.
6 Перелік графічного матеріалу:
	Схема бази даних, інтерфейси сторінок, діаграма прецедентів, діаграма розгортання, діаграма пакетів.
КАЛЕНДАРНИЙ ПЛАН
Номер	Назва етапів курсової роботи	Термін виконання етапів роботи	Примітка
1	Функціональна специфікація
програмного проекту	31.03.2024	
2	Проектування програмного
проекту	30.04.2024	
3	Кодування програмного проекту	8.06.2024	
4	Оформлення пояснювальної
записки	16.06.2024	
5	Захист курсової роботи	16.06.2024	


Дата видачі завдання: 11 березня 2024 р.

Керівник  							   доц. каф. ПІ Лещинська І. О.

Завдання прийняв до виконання 
ст. гр. ПЗПІ-21-3 								   Бондаренко К. Т.

РЕФЕРАТ

Пояснювальна записка до курсової роботи: 68 с., 11 рис., 14 додатків, 5 джерел посилання.
Об'єктом розробки в даній курсовій роботі є інтегрована система моніторингу та аналізу фізичного стану спортсменів, яка об'єднує програмні рішення для обробки даних IoT пристроїв, серверну частину для управління та зберігання даних, а також клієнтську частину для зручної візуалізації і взаємодії з користувачем. 
Основною метою роботи було створення комплексної системи, яка дозволяє збирати, зберігати і аналізувати дані про фізичні показники спортсменів, забезпечуючи таким чином можливість покращення процесу тренувань і підвищення ефективності підготовки до змагань.
Методи розробки включали використання мікроконтролерів та сенсорів для збору даних про фізичний стан спортсменів, застосування веб-технологій для розробки серверної частини. Для клієнтської частини використовувалися фреймворки Angular.
Результати виконання курсової роботи включають створення функціональної системи, яка забезпечує надійне зберігання і управління цими даними, а також надає користувачам зручний інтерфейс для доступу до аналітичних даних. Система дозволяє тренерам і спортивним аналітикам отримувати вичерпну інформацію про фізичний стан і ефективність тренувань спортсменів, що сприяє покращенню індивідуальних тренувальних програм та досягненню кращих результатів у змаганнях.
Ключові слова: МОНІТОРИНГ ФІЗИЧНОЇ ПІДГОТОВКИ, АНАЛІЗ ДАНИХ, КОМАНДА, АТЛЕТ, ТРЕНУВАННЯ, МЕТРИКИ.

ЗМІСТ

ВСТУП…………………………………………………………………………….7
1 ВІДОМОСТІ ПРО ПРЕДМЕТ РОЗРОБКИ…………………………………...8
1.1 Опис предметної області………………………………………………8
1.2 Опис програмної системи……………………………………………..9
2 АРХІТЕКТУРА ТА ПРОЄКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ……...11
2.1 Архітектура програмного забезпечення…………………………….11
2.2 Структура бази даних………………………………………………...14
3 ОПИС ПРОГРАМНИХ РІШЕНЬ…………………………………………….18
3.1 Вибір програмних засобів……………………………………………18
3.2 Програмні рішення серверної частини……………………………...18
3.2.1 Автентифікація та авторизація……………………………...19
3.2.2 Взаємодія з базою даних…………………………………….19
3.2.3 Безпека даних………………………………………………...19
3.2.4 Створення резервної копії бази даних……………………...20
3.3 Програмні рішення клієнтської частини……………………………21
3.3.1 Взаємодія з сервером………………………………………..21
3.3.2 Локалізація…………………………………………………...21
3.3.3 Інтерфейс……………………………………………………..22
3.4 Програмні рішення частини розумного девайсу…………………...26
ВИСНОВКИ……………………………………………………………………..28
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ……………………………………………29
ДОДАТОК А GenericRepository.cs……………………………………………..30
ДОДАТОК Б AppDbContext.cs ………………………………………………...32
ДОДАТОК В Session.cs…………………………………………………………33
ДОДАТОК Г AuthService.cs…………………………………………………….35
ДОДАТОК Ґ SessionEndpointDefinition.cs……………………………………..38
ДОДАТОК Д session-item-component.ts………………………………………..43
ДОДАТОК Е REST API Специфікація…………………………………………47
ДОДАТОК Є Файл локалізації en.json…………………………………………49
ДОДАТОК Ж Файл локалізації ua.json………………………………………...51
ДОДАТОК З JwtService.cs………………………………………………………53
ДОДАТОК И sketch.uno…………………………………………………………54
ДОДАТОК І PerformanceMetrics.sql……………………………………………60
ДОДАТОК Ї DependencyRegistrar.cs……………………………………………61
ДОДАТОК Й DatabaseService.cs………………………………………………..62

ВСТУП

В умовах сучасного спортивного світу, де досягнення високих результатів залежить від досконалого моніторингу та аналізу фізичних показників спортсменів, виникає потреба у програмних рішеннях, які дозволяють забезпечити всебічний контроль за здоров'ям і підготовкою. Розроблена в межах курсової роботи система спрямована на забезпечення інтегрованого підходу до моніторингу та аналізу фізичних показників спортсменів. Вона буде застосовуватися в спортивних командах, клубах, академіях та індивідуальними спортсменами для підвищення ефективності тренувань і досягнення оптимальних результатів у змаганнях.
Актуальність розробки обумовлена зростаючою потребою у покращенні методів контролю за фізичним станом спортсменів в умовах жорсткої конкуренції. Існуючі рішення на ринку, такі як Catapult Sports, PlayerTek і STATSports, хоч і надають базові можливості для збору та аналізу даних, мають значні обмеження у функціональності, інтеграції з різними девайсами та розширеній аналітиці. Вони не завжди можуть забезпечити повний та комплексний моніторинг, що знижує їхню ефективність. Моя система, інтегруючи дані з різних пристроїв та використовуючи розширені аналітичні методи, надасть більш повний образ фізичного стану спортсменів, тим самим покращуючи процес ухвалення тренувальних рішень і допомагаючи у досягненні вищих спортивних результатів.
Метою курсової роботи є розробка програмної системи для комплексного моніторингу здоров'я та фізичних показників спортивних команд. Успішне впровадження цієї системи сприятиме підвищенню ефективності тренувань, покращенню фізичних показників спортсменів і допоможе спортивним командам досягти нових висот у своїх спортивних досягненнях.

1 ВІДОМОСТІ ПРО ПРЕДМЕТ РОЗРОБКИ
1.1 Опис предметної області

	Програмна система для комплексного моніторингу здоров'я та фізичних показників спортивних команд вирішує важливі задачі у спортивній сфері. Сучасний спорт, особливо на професійному рівні, вимагає інтегрованого підходу до оцінки фізичного стану спортсменів, адже навіть незначні деталі можуть значно вплинути на результати змагань. Успіх у спорті залежить від різноманітних факторів: від фізичних показників спортсмена до стратегічних рішень тренера. З огляду на це, предметною областю цієї розробки є комплексний моніторинг фізичного стану спортсменів, аналіз тренувальних навантажень.
В основі системи лежить збір, обробка та аналіз даних, що відображають фізичний стан спортсменів, такі як серцевий ритм, частота дихання, температура тіла, рівень втоми та інші. Це дозволяє тренерам приймати обґрунтовані рішення щодо тренувальних програм, а також забезпечує спортсменів інформацією про їхній поточний фізичний стан, що сприяє підвищенню ефективності їх підготовки та зменшує ризик травмування.
Сучасні спортивні тренування включають широкий спектр активностей, кожна з яких накладає певні вимоги на фізичну форму спортсменів. Наприклад, у футболі критично важливими є витривалість, швидкість і сила, тоді як у важкій атлетиці основну роль відіграє сила. Оцінка таких параметрів може бути складною без спеціалізованих засобів, які дозволяють відстежувати показники в реальному часі та аналізувати їх. Тому система, яка забезпечує таку функціональність, стане незамінним інструментом для тренерів і спортсменів.
Основними компонентами системи є сенсори для збору даних, програмне забезпечення для обробки цих даних та інтерфейс для їх візуалізації та аналізу. Сенсори можуть включати носимі пристрої, такі як фітнес-браслети, датчики, що закріплюються на тілі спортсмена, та інші пристрої, які фіксують фізіологічні параметри. Всі ці дані передаються у програму, де відбувається їх обробка та аналіз, з подальшим наданням тренерам інформації про стан спортсменів у вигляді графіків, звітів та рекомендацій.
Система також сприяє покращенню координації між різними учасниками тренувального процесу, зокрема тренерами, лікарями та самими спортсменами. Інформація про фізичний стан спортсменів, яка доступна в реальному часі, дозволяє всім зацікавленим сторонам приймати спільні рішення щодо тренувального режиму, реабілітаційних заходів та інших аспектів підготовки. Це значно підвищує ефективність командної роботи і покращує результати.

1.2 Опис програмної системи

Програмна система для моніторингу координації спортсменів і управління тренувальними сесіями поєднує різноманітні технологічні компоненти: IoT пристрій на базі Arduino, бекенд на .NET API та фронтенд на Angular. Її основна мета полягає в зборі та обробці даних про фізичні показники атлетів, а також наданні тренерам можливості створювати і контролювати тренувальні сесії, покращуючи тренувальний процес завдяки детальному аналізу зібраних даних.
Серверна частина системи функціонує як програмний інтерфейс застосунку (API) для управління даними та забезпечення взаємодії з користувачами. Цей компонент відповідає за створення і редагування команд, додавання атлетів до команд, а також організацію тренувальних сесій. Програмний інтерфейс підтримує функції для збору даних про фізичні показники спортсменів та їх збереження у базі даних. Основні можливості серверної частини включають обробку запитів від фронтенд додатку, агрегацію і збереження зібраних даних, а також забезпечення доступу до цієї інформації через програмний інтерфейс, що відповідає специфікації REST. Таким чином, ця частина програми надає централізовану точку для управління всіма аспектами системи, зокрема даними про команди, користувачів, атлетів і тренувальні сесії.
Клієнтська частина системи забезпечує інтерактивний користувацький інтерфейс, де тренери можуть переглядати фізичні показники атлетів у вигляді графіків і діаграм. Цей компонент надає інструменти для візуалізації даних, отриманих з бекенду, дозволяючи відстежувати і аналізувати показники спортсменів під час тренувальних сесій. Інтерфейс дозволяє створювати, редагувати і переглядати тренувальні сесії, а також взаємодіяти з командою і атлетами.
Розумний пристрій виконує функцію автономного датчика, що відповідає за збір даних про крен, тангаж і рискання спортсмена. Пристрій не підключений безпосередньо до системи, але він забезпечує важливі дані про просторову координацію спортсмена, що можуть використовуватися для подальшого аналізу. Сенсори відстежують кутове положення і просторовий рух атлета, дозволяючи оцінити його фізичні показники у тривимірному просторі.
Взаємодія між компонентами системи організована таким чином, що дані, зібрані розумними пристроями, передаються до серверної частини для обробки і збереження. Серверна частина обробляє ці дані і надає їх у вигляді, що підходить для візуалізації на клієнтській частині. Клієнтська частина відображає ці дані у вигляді інтерактивних графіків і діаграм, дозволяючи користувачам аналізувати фізичні показники атлетів.

2 АРХІТЕКТУРА ТА ПРОЄКТУВАННЯ СИСТЕМИ
2.1 Архітектура програмного забезпечення

Архітектура програмного забезпечення системи розподілена на дві основні частини: серверну і клієнтську. Серверна частина розроблена з використанням підходу домен-орієнтованого проектування (DDD), тоді як клієнтська частина побудована на основі компонентної архітектури.
Для серверної частини було обрано домен-орієнтоване проектування (DDD). Цей підхід дозволяє зосередитися на бізнес-логіці та доменних процесах, забезпечуючи глибоке розуміння предметної області і чітке розмежування між різними доменами системи. DDD надає можливість розділити систему на окремі доменні області, такі як доменні моделі, сервіси та репозиторії, що сприяє чіткій структурі коду. Це значно полегшує підтримку та розвиток програмного забезпечення, оскільки кожен компонент системи виконує конкретну функцію і взаємодіє з іншими компонентами через чітко визначені інтерфейси. На рисунку 1 зображена діаграма пакетів серверної частини.

Рисунок 1 – Діаграма пакетів серверної частини.

Клієнтська частина системи використовує компонентну архітектуру, яка забезпечує модульність і повторне використання коду. Компонентна архітектура дозволяє створювати незалежні, самодостатні компоненти, що мають власну логіку, шаблон і стилі. Це значно полегшує управління кодом, тестування, обслуговування та організацію проекту в цілому. Компоненти можуть управляти власним станом або спільним станом через сервіси, що робить управління станом додатку більш передбачуваним і легким. Ізольованість компонентів забезпечує мінімальний вплив змін в одному компоненті на інші частини системи, що покращує стабільність і полегшує внесення змін або додавання нових функцій. На рисунку 2 зображено діаграму компонентів клієнтської частини.

Рисунок 2 – Діаграма компонентів клієнтської частини.

IoT компонент системи має значно простішу архітектуру. IoT пристрій здійснює моніторинг крену, тангажу та рискання, щоб визначити координацію спортсмена в просторі. Основне завдання IoT пристрою полягає в зборі і первинній обробці даних, які потім можуть бути використані для подальшого аналізу. Через специфіку апаратного забезпечення та варіативність використаних девайсів, архітектура IoT компонента може змінюватися в залежності від конкретного пристрою та його можливостей. Відсутність складної архітектури для коду пояснюється його призначенням для одного конкретного завдання - збір даних про рух, крен тангаж та рискання. На рисунку 3 зображена діаграма пакетів IoT компоненту.
Рисунок 3 – Діаграма пакетів IoT компоненту.

2.2 Структура бази даних

Структура бази даних системи розроблена для забезпечення ефективного управління інформацією про користувачів, команди, атлетів, сесії, спортивні дані та інші компоненти, необхідні для функціонування системи. База даних має реляційну модель, в якій основні дані зберігаються в таблицях, а взаємозв’язки між ними встановлюються за допомогою зовнішніх ключів. Вона побудована з використанням Microsoft SQL Server і включає кілька таблиць, кожна з яких відіграє конкретну роль у системі.
Таблиця AspNetRoleClaims зберігає інформацію про зв’язок між ролями та їхніми клеймами. Клейми представляють собою додаткові властивості або атрибути, що прив'язуються до ролей. Таблиця містить стовпці Id, ClaimType, ClaimValue та RoleId, де Id є первинним ключем, а RoleId посилається на таблицю AspNetRoles, встановлюючи відношення "один до багатьох" між ролями та їхніми клеймами.
Таблиця AspNetRoles зберігає ролі, визначені в системі, включаючи такі поля, як Id, ConcurrencyStamp, Name та NormalizedName. Поле Id є первинним ключем і унікально ідентифікує кожну роль.
Таблиця AspNetUserClaims містить клейми, прив'язані до користувачів. Вона має поля Id, ClaimType, ClaimValue та UserId, де UserId посилається на таблицю AspNetUsers, встановлюючи зв’язок між клеймами користувача та самим користувачем.
Таблиця AspNetUserLogins відповідає за зберігання інформації про зовнішні входи в систему для користувачів, наприклад, через соціальні мережі. Вона включає LoginProvider, ProviderKey, ProviderDisplayName та UserId, з LoginProvider та ProviderKey у якості складеного первинного ключа.
Таблиця AspNetUserRoles відображає зв'язок між користувачами і їх ролями, маючи поля UserId і RoleId, які разом утворюють складений первинний ключ. Це дозволяє одному користувачеві мати кілька ролей.
Таблиця AspNetUsers зберігає інформацію про користувачів системи, включаючи такі поля як Id, AthleteId, FirstName, LastName, Image, Age, AccessFailedCount, ConcurrencyStamp, Email, EmailConfirmed, LockoutEnabled, LockoutEnd, NormalizedEmail, NormalizedUserName, PasswordHash, PhoneNumber, PhoneNumberConfirmed, SecurityStamp, TwoFactorEnabled, UserName. AthleteId є зовнішнім ключем, що посилається на таблицю Athletes, встановлюючи зв’язок між користувачем і атлетом.
Таблиця AspNetUserTokens зберігає токени для користувачів. Вона має поля UserId, LoginProvider, Name, Value, з UserId, LoginProvider і Name, що разом складають первинний ключ, і встановлює зв'язок з таблицею AspNetUsers через поле UserId.
Таблиця Athletes містить інформацію про атлетів, включаючи Id та UserId, де UserId є зовнішнім ключем, що посилається на таблицю AspNetUsers.
Таблиця HealthMetrics збирає дані про показники здоров'я атлетів. Вона має поля Id, SessionId, TeamAthleteId, MetricType, MetricValue та TimeStamp. Поле SessionId посилається на таблицю Sessions, а TeamAthleteId на таблицю TeamAthletes.
Таблиця PerformanceMetrics зберігає дані про продуктивність атлетів. Вона має аналогічну структуру з полями Id, SessionId, TeamAthleteId, MetricType, MetricValue та TimeStamp, з відповідними зовнішніми ключами на таблиці Sessions і TeamAthletes.
Таблиця Sessions відповідає за управління тренувальними сесіями команд, включаючи Id, TeamId, Date, EndDate та Duration. Поле TeamId посилається на таблицю Teams.
Таблиця Sports містить інформацію про види спорту, зберігаючи Id, Name та Description.
Таблиця TeamAthletes відображає зв'язок між атлетами і командами, включаючи Id, AthleteId, TeamId, і DateJoined. Вона встановлює зв’язок між таблицями Athletes і Teams через відповідні зовнішні ключі.
Таблиця Teams зберігає інформацію про команди, включаючи Id, Name, Description, CountryName та SportId, де SportId посилається на таблицю Sports.
На рисунку 4 зображена діаграма бази даних.
Рисунок 4 – Діаграма бази даних.

Ця структура бази даних забезпечує надійне зберігання і управління даними, необхідними для функціонування системи. Вона підтримує розширену авторизацію і автентифікацію, управління командами, атлетами та їхніми тренувальними даними, а також забезпечує зв’язок між всіма компонентами системи.

3 ОПИС ПРОГРАМНИХ РІШЕНЬ
3.1 Вибір програмних засобів 

Для реалізації проекту були обрані такі програмні рішення: .NET для серверної частини, Angular для клієнтської частини, та Arduino для IoT пристрою збору даних.
.NET було обрано для серверної частини через його високу продуктивність, масштабованість і широку підтримку. .NET API дозволяє ефективно створювати високопродуктивні серверні додатки з використанням сучасних технологій безпеки і відповідності стандартам. Він забезпечує легку інтеграцію з іншими сервісами та інструментами, такими як бази даних і хмарні сервіси. Частини програмного коду та REST-специфікація розміщені у додатках.
Angular було обрано для клієнтської частини через його компонентну архітектуру і потужні інструменти розробки. Angular дозволяє побудувати модульні, легко підтримувані компоненти для відображення фізичних показників атлетів та інтерактивних графіків. Він забезпечує ефективний обмін даними з серверною частиною через REST API і підтримує створення прогресивних веб-додатків.
Arduino було обрано для IoT пристрою через його простоту використання і гнучкість. Arduino пропонує доступ до широкого спектру сенсорів і модулів, необхідних для збору даних про рух та координацію спортсменів у просторі.

3.2 Програмні рішення серверної частини
3.2.1 Автентифікація та авторизація

Обравши JWT (JSON Web Token) автентифікацію для серверної частини, я зосередився на використанні цього стандарту через його численні переваги у контексті безпеки та ефективності. JWT забезпечує можливість генерації токенів, які містять інформацію про користувача та його права, підписані секретним ключем сервера. Це дозволяє клієнтам автентифікувати свої запити до сервера та отримувати доступ до захищених ресурсів без необхідності постійної перевірки ідентифікаційних даних. Частина коду, що генерує JWT токен наведена у додатку З.

3.2.2 Взаємодія з базою даних

Я обрав підход Database First для розробки бази даних. Цей підхід дозволяє зосередитися на створенні оптимальної схеми бази даних з необхідними зв'язками між таблицями та оптимізації використання ресурсів бази даних. Використання Entity Framework із генерацією моделей даних автоматично спрощує розробку та інтеграцію з базою даних, забезпечуючи швидку реалізацію і масштабування системи. Я створив окремий проєкт для збереження таблиць на мові T-SQL та оновлення бази даних. Таблиця PerformanceMetrics наведена у додатку І.

3.2.3 Безпека даних

Особливу увагу приділив забезпеченню безпеки даних, використовуючи механізми хешування паролів. Це означає, що фактичні паролі користувачів не зберігаються у відкритому вигляді в базі даних, а представлені у вигляді хеш-кодів, що ускладнює їх зламання в разі несанкціонованого доступу. Додатково, я використовую параметризовані запити та заходи протидії SQL ін'єкціям для захисту від потенційних атак, що забезпечує стійкість системи до небезпечних впливів з боку зловмисників. Частина коду, що налаштовує складність паролю, наведена у додатку Ї.

3.2.4 Створення резервної копії бази даних

Для забезпечення безперервності роботи і захисту даних, я реалізував процес створення резервних копій бази даних та її відновлення за допомогою спеціалізованого сервісу. Сервіс для резервного копіювання та відновлення бази даних є критично важливим для збереження цілісності даних та забезпечення їх доступності в разі непередбачених ситуацій, таких як збої в апаратному або програмному забезпеченні. Даний сервіс дозволяє створювати резервні копії бази даних у визначеному місці з можливістю відновлення її у разі необхідності.
В основі процесу резервного копіювання лежить використання SQL-запитів для створення файлів резервних копій на основі поточного стану бази даних. Код для створення резервних копій складається з кількох важливих етапів. Спочатку визначається шлях, де буде зберігатися резервна копія, використовуючи метод BuildBackupPathWithFilename, який генерує ім'я файлу резервної копії на основі імені бази даних та поточної дати. Далі встановлюється з'єднання з базою даних за допомогою рядка підключення, який витягується з конфігурації. Після цього виконується SQL-запит BACKUP DATABASE, який зберігає резервну копію бази даних у вказаному місці на диску.
Процес відновлення бази даних включає перехід бази в режим однокористувацького доступу, завантаження резервної копії з диска та повернення бази в режим багатокористувацького доступу. Це дозволяє уникнути конфліктів та забезпечити правильність процесу відновлення. Перший етап відновлення включає в себе встановлення бази даних у режимі однокористувацького доступу, що дозволяє виконувати ексклюзивні операції на ній без втручання інших користувачів. Для цього використовується SQL-запит з командою ALTER DATABASE, що встановлює режим однокористувацького доступу. Далі відбувається безпосередньо процес відновлення за допомогою SQL-запиту RESTORE DATABASE, який використовує шлях до файлу резервної копії на диску.
Після відновлення база даних переводиться назад у режим багатокористувацького доступу, що дозволяє користувачам знову отримувати до неї доступ. Цей процес важливий для забезпечення того, щоб усі користувачі могли безперешкодно працювати з базою даних після завершення відновлення. Код DatabaseService розміщений у додатку Й.

	3.3 Програмні рішення клієнтської частини
	3.3.1 Взаємодія з сервером

	Основу взаємодії з сервером у моєму додатку становлять сервіси Angular, які забезпечують інкапсуляцію логіки обробки HTTP-запитів. Це дає змогу зосередити всі операції з обміну даними між клієнтською та серверною частинами в одному місці, що значно спрощує управління інформацією та покращує підтримуваність коду.
Сервіси Angular у моєму додатку відповідають за різні функціональні області, включаючи управління командами, атлетами, метриками здоров’я, продуктивністю та сесіями. Кожен сервіс реалізує набір методів для виконання основних операцій CRUD (Create, Read, Update, Delete) з використанням HttpClient. Приклад такого компоненту наведений у додатку Д.

	3.3.2 Локалізація

Для забезпечення локалізації використовується бібліотека ngx-translate, що дозволяє адаптувати інтерфейс користувача до різних мовних налаштувань.
Бібліотека інтегрується безпосередньо з Angular, що спрощує процес перекладу текстових ресурсів у всьому додатку. Вихідними данними для перекладу є файли JSON, які містять рядки тексту для кожної мови, що підтримується додатком (наприклад, en.json для англійської мови та ua.json для української).
Компонент LanguageComponent відповідає за управління поточною мовою. У конструкторі компонента налаштовується сервіс TranslateService, де визначаються підтримувані мови та мова за замовчуванням. При виборі мови методом switchLanguage() відбувається зміна активної мови та оновлення інтерфейсу згідно з обраною мовою користувача.
Приведений у прикладі файл en.json містить рядки тексту для англійської мови, які використовуються в різних частинах додатку. Наприклад, відповідно до файлу en.json, текст кнопки "Log in" перекладений як "Log in", інформаційний текст на головній сторінці описує можливості системи для моніторингу і фізичної підготовки спортсменів.
Цей підхід забезпечує легку масштабованість та підтримку нових мов, що особливо важливо для додатків з міжнародною аудиторією. Він дозволяє зосередитися на функціональності додатку, не витрачаючи час на переклад та управління мовними ресурсами вручну. Файли en.json та ua.json наведені у додатках Є та Ж .

	3.3.3 Інтерфейс
	Головна сторінка надає користувачеві загальний огляд системи. Після входу користувач бачить основну панель, яка містить навігаційне меню та інформаційну панель (див. рис. 5).
Рисунок 5 – Головна сторінка системи та навігаційне меню.

На сторінці команд представлений список всіх команд, зареєстрованих у системі (див. рис. 6). Також присутня кнопка для створення команди (див. рис. 7).
Рисунок 6 – Сторінка команд

Рисунок 7 – Сторінка створення команди.

В межах сторінки команди інтегрований розділ для перегляду сесій (див. рис. 8). Цей розділ відображає всі тренувальні сеанси, проведені командою. Ще однією важливою функцією сторінки команди є перегляд різних метрик спортсменів (див. рис. 9). Цей розділ надає детальний аналіз фізичних показників кожного спортсмена в команді для кожної тренувальної сесії.
Рисунок 8 – Сторінка команди.

Рисунок 9 – Сторінка сесії з метриками спортсменів.

Сторінка користувачів призначена для управління користувачами системи (див. рис. 10). Видаляти користувачів можуть лише адміністратори.
Рисунок 10 – Сторінка користувачів.

Для демонстрації локалізації інтерфейсу у верхньому правому куті розташовані кнопки вибору мови (див. рис. 11).  При зміні мови оновлюється весь текст інтерфейсу, що підтверджує коректність роботи локалізації і дозволяє використовувати систему різним користувачам без бар'єрів мови.

Рисунок 11 – Кнопки вибору мови.

Інтерфейс системи розроблено з акцентом на зручність користування та інтуїтивність. Ключові функції організовані у чітко визначені розділи, що дозволяє користувачам легко знаходити необхідну інформацію та здійснювати дії. Локалізація забезпечує адаптацію інтерфейсу до мовних потреб користувачів, що підвищує привабливість системи для міжнародної аудиторії.

	3.4 Програмні рішення частини розумного девайсу 

У процесі розробки IoT-частини проєкту я інтегрував сенсори та дисплеї з метою збору, обробки та відображення даних про навколишнє середовище. Для цього я обрав платформу Arduino та використовував популярні компоненти, такі як датчик MPU6050 і дисплей Adafruit SSD1306. Вибір цієї платформи був продиктований її гнучкістю, наявністю великої кількості бібліотек та можливістю легкої інтеграції з різними периферійними пристроями.
Arduino, на базі якого я реалізував IoT-рішення, надає спрощену модель програмування для мікроконтролерів, що дозволяє швидко розробляти прототипи пристроїв. У моєму випадку я використав мікроконтролер для збору даних з датчика MPU6050, який вимірює акселерометричні та гіроскопічні показники. Цей датчик дозволяє відстежувати кутові положення та рухи пристрою в трьох вимірах, що є критично важливим для багатьох застосувань IoT.
Для зчитування даних з датчика MPU6050 я використав протокол I2C, який забезпечує ефективну комунікацію між мікроконтролером і периферійними пристроями. У моєму коді я налаштував зв'язок з датчиком через I2C, вказавши його адресу та конфігурацію. Використовуючи бібліотеку Wire, я ініціалізував зв'язок з датчиком, надіславши необхідні команди для його активації та налаштування. Після цього я зчитував дані з регістрів датчика, конвертувавши сирі показники в корисні фізичні значення, такі як прискорення та кутові швидкості.
Під час обробки даних з датчика я обчислював кути нахилу пристрою за допомогою алгоритмів, які комбінують показники акселерометра та гіроскопа. Використовуючи відомі формули, я перетворював значення з акселерометра в кути нахилу відносно осей X і Y, а також обчислював кутову швидкість обертання навколо осі Z за допомогою гіроскопа. Щоб отримати точні кути нахилу (roll, pitch), я застосовував метод злиття даних, комбінуючи показники гіроскопа та акселерометра, де гіроскопічні дані надають більшу вагу, оскільки вони менш схильні до шумів та зовнішніх впливів.
Для відображення зібраних та оброблених даних я використав OLED дисплей Adafruit SSD1306, підключений до мікроконтролера також через I2C. Цей дисплей забезпечує високу контрастність і низьке енергоспоживання, що є ідеальним для відображення показників у реальному часі. У своєму коді я використав бібліотеку Adafruit_GFX та Adafruit_SSD1306, які надають зручні методи для управління дисплеєм, включаючи функції для відображення тексту, малювання графічних примітивів та очищення екрану. Програмний код наведений у додатку И.
ВИСНОВКИ

В результаті курсової роботи я розробив систему для управління спортивними командами та моніторингу фізичних показників атлетів під час тренувань. Система дозволяє створювати команди, додавати атлетів, організовувати тренувальні сесії та відстежувати їх фізичні показники, що забезпечує ефективний контроль і управління тренувальним процесом. Розробка цієї системи дала мені глибше розуміння інтеграції різних програмних компонентів, зокрема серверної і клієнтської частини, а також роботи з IoT пристроями для збору даних. Я навчився проектувати програмне забезпечення з урахуванням вимог безпеки, взаємодії з базою даних та ефективного відображення даних користувачам.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1.	"Проектування доменно-орієнтованих систем. Розплутування складнощів у серці програмного забезпечення" Ерік Еванс
2.	"Шаблони архітектури додатків" Мартін Фаулер
3.	"Шаблони проектування. Елементи повторного використання об'єктно-орієнтованого програмування" Еріх Гамма, Річард Хельм, Ральф Джонсон, Джон Вліссідес
4.	Демо функціонального тестування. URL: https://youtu.be/lZebSqPIGUA
5.	Програмний код системи. URL: https://github.com/NureBondarenkoKostiantyn/apzkr-pzpi-21-3-bondarenko-kostiantyn

ДОДАТОК А
GenericRepository.cs

1. public class GenericRepository<TEntity>: IGenericRepository<TEntity> where TEntity: class
2. {
3.     private readonly AppDbContext _context;
4.     protected readonly DbSet<TEntity> DbSet;
5. 
6.     protected GenericRepository(AppDbContext context)
7.     {
8.         _context = context;
9.         DbSet = context.Set<TEntity>();
10.     }
11. 
12.     public async Task<IEnumerable<TEntity>> GetAllAsync(
13.         bool asNoTracking = false, 
14.         CancellationToken cancellationToken = default)
15.     {
16.         return asNoTracking
17.             ? await DbSet.AsNoTracking().ToListAsync(cancellationToken)
18.             : await DbSet.ToListAsync(cancellationToken);
19.     }
20. 
21.     public async Task CreateAsync(
22.         TEntity entity, 
23.         CancellationToken cancellationToken = default)
24.     {
25.         await _context.AddAsync(entity, cancellationToken);
26.     }
27. 
28.     public void Update(TEntity entity)
29.     {
30.         _context.Update(entity);
31.     }
32. 
33.     public void Delete(TEntity entity)
34.     {
35.         _context.Remove(entity);
36.     }
37. }

ДОДАТОК Б
AppDbContext.cs

1. public sealed class AppDbContext: IdentityDbContext<User, Role, Guid>
2. {
3.     public AppDbContext(DbContextOptions<AppDbContext> options): base(options)
4.     {
5.     }
6. 
7.     protected override void OnModelCreating(ModelBuilder modelBuilder)
8.     {
9.         base.OnModelCreating(modelBuilder);
10. 
11.         modelBuilder.ApplyConfigurationsFromAssembly(typeof(AppDbContext).Assembly);
12.     }
13.     
14.     public DbSet<Sport> Sports { get; private set; }
15.     public DbSet<Athlete> Athletes { get; private set; }
16.     public DbSet<Team> Teams { get; private set; }
17.     public DbSet<TeamAthlete> TeamAthletes { get; private set; }
18.     public DbSet<Session> Sessions { get; private set; }
19.     public DbSet<PerformanceMetric> PerformanceMetrics { get; private set; }
20.     public DbSet<HealthMetric> HealthMetrics { get; private set; }
21. }

ДОДАТОК В
Session.cs

1. public class Session: BaseAggregateRoot
2. {
3.     public Guid TeamId { get; private set; }
4.     public DateTime Date { get; private set; }
5.     public DateTime EndDate { get; private set; }
6.     public int Duration { get; private set; }
7.     
8.     private readonly List<PerformanceMetric> _performanceMetrics = [];
9.     private readonly List<HealthMetric> _healthMetrics = [];
10. 
11.     public IReadOnlyCollection<PerformanceMetric> PerformanceMetrics => _performanceMetrics;
12.     public IReadOnlyCollection<HealthMetric> HealthMetrics => _healthMetrics;
13.     
14.     public Session(Guid teamId, int duration) : base(Guid.NewGuid())
15.     {
16.         TeamId = teamId;
17.         Date = DateTime.UtcNow;
18.         EndDate = Date.AddMinutes(duration);
19.         Duration = duration;
20.     }
21. 
22.     public void AddPerformanceMetric(PerformanceMetric performanceMetric)
23.     {
24.         if (_performanceMetrics.All(x => x.Id != performanceMetric.Id))
25.         {
26.             _performanceMetrics.Add(performanceMetric);
27.         }
28.     }
29. 
30.     public void PopulatePerformanceMetrics(IEnumerable<PerformanceMetric> performanceMetrics)
31.     {
32.         var validPerformanceMetrics = performanceMetrics
33.             .Where(x => !_performanceMetrics.Contains(x));
34.         _performanceMetrics.AddRange(validPerformanceMetrics);
35.     }
36. 
37.     public void AddHealthMetric(HealthMetric healthMetric)
38.     {
39.         if (_healthMetrics.All(x => x.Id != healthMetric.Id))
40.         {
41.             _healthMetrics.Add(healthMetric);
42.         }
43.     }
44. 
45.     public void PopulateHealthMetrics(IEnumerable<HealthMetric> healthMetrics)
46.     {
47.         var validHealthMetrics = healthMetrics
48.             .Where(x => !_healthMetrics.Contains(x));
49.         _healthMetrics.AddRange(validHealthMetrics);
50.     }
51. }

ДОДАТОК Г
AuthService.cs

1. public class AuthService: IAuthService
2. {
3.     private readonly UserManager<User> _userManager;
4.     private readonly SignInManager<User> _signInManager;
5.     private readonly IMapper _mapper;
6.     private readonly IJwtService _jwtHandler;
7. 
8.     public AuthService(
9.         UserManager<User> userManager,
10.         SignInManager<User> signInManager,
11.         IMapper mapper, 
12.         IJwtService jwtHandler)
13.     {
14.         _userManager = userManager;
15.         _signInManager = signInManager;
16.         _mapper = mapper;
17.         _jwtHandler = jwtHandler;
18.     }
19. 
20.     public async Task<JwtTokenDto> LoginAsync(
21.         LoginDto loginDto,
22.         CancellationToken cancellationToken = default)
23.     {
24.         var user = await _userManager.FindByEmailAsync(loginDto.Email)
25.             ?? throw new ApplicationException("Invalid email or password");
26. 
27.         var result = await _signInManager
28.             .PasswordSignInAsync(user, loginDto.Password, false, false);
29. 
30.         if (!result.Succeeded)
31.         {
32.             throw new ApplicationException("Invalid email or password");
33.         }
34. 
35.         var claims = await _jwtHandler.GetClaimsAsync(user.Id);
36.         var signingCredentials = _jwtHandler.GetSigningCredentials();
37.         var token = _jwtHandler.GenerateToken(signingCredentials, claims);
38. 
39.         return new JwtTokenDto
40.         {
41.             Token = new JwtSecurityTokenHandler().WriteToken(token),
42.         };
43.     }
44. 
45.     public async Task SignupAsync(
46.         SignupDto signupDto,
47.         CancellationToken cancellationToken = default)
48.     {
49.         var user = _mapper.Map<User>(signupDto);
50. 
51.         user.UserName = user.Email;
52.         
53.         var result = await _userManager.CreateAsync(user, signupDto.Password);
54. 
55.         if (!result.Succeeded)
56.         {
57.             throw new ApplicationException(result.ToString());
58.         }
59.     }
60. 
61.     public async Task ResetPasswordAsync(
62.         ChangePasswordDto changePasswordDto,
63.         CancellationToken cancellationToken = default)
64.     {
65.         var user = await _userManager.FindByEmailAsync(changePasswordDto.Email)
66.                    ?? throw new ApplicationException($"User with email {changePasswordDto.Email} was not found");
67. 
68.         var token = await _userManager.GeneratePasswordResetTokenAsync(user);
69.         var result = await _userManager.ResetPasswordAsync(user, token, changePasswordDto.Password);
70. 
71.         if (!result.Succeeded)
72.         {
73.             throw new ApplicationException("Failed to reset password");
74.         }
75.     }
76. }

ДОДАТОК Ґ
SessionEndpointDefinition.cs

1. public class SessionEndpointDefinition : IEndpointDefinition
2. {
3.     public void RegisterEndpoints(WebApplication app)
4.     {
5.         var sessionGroup = app.MapGroup("/api/sessions");
6. 
7.         sessionGroup.MapGet("/", GetSessions);
8.         sessionGroup.MapGet("/{id:guid}", GetSession);
9.         sessionGroup.MapGet("/{id:guid}/performanceMetrics", GetPerformanceMetrics);
10.         sessionGroup.MapGet("/{id:guid}/healthMetrics", GetHealthMetrics);
11.         sessionGroup.MapPost("/", CreateSession);
12.         sessionGroup.MapPost("/{id:guid}/performanceMetrics", CreatePerformanceMetric);
13.         sessionGroup.MapPost("/{id:guid}/performanceMetrics/batch", PopulatePerformanceMetrics);
14.         sessionGroup.MapPost("/{id:guid}/healthMetrics", CreateHealthMetric);
15.         sessionGroup.MapPost("/{id:guid}/healthMetrics/batch", PopulateHealthMetrics);
16.         sessionGroup.MapDelete("/{id:guid}", DeleteSession);
17.     }
18. 
19.     private static async Task<IResult> GetSessions(
20.         IMediator mediator,
21.         [BindRequired] Guid teamId)
22.     {
23.         var sessions = await mediator.Send(new GetSessionsQuery(teamId));
24.         return Results.Ok(sessions);
25.     }
26. 
27.     private static async Task<IResult> GetSession(
28.         IMediator mediator,
29.         [FromRoute] Guid id)
30.     {
31.         var session = await mediator.Send(new GetSessionByIdQuery(id));
32.         return Results.Ok(session);
33.     }
34.     
35.     private static async Task<IResult> GetPerformanceMetrics(
36.         IMediator mediator,
37.         [FromRoute] Guid id,
38.         [AsParameters] GetPerformanceMetricsRequest getPerformanceMetricsRequest)
39.     {
40.         var performanceMetrics = await mediator.Send(new GetPerformanceMetricsQuery(
41.             id,
42.             getPerformanceMetricsRequest.AthleteId,
43.             getPerformanceMetricsRequest.MetricType,
44.             getPerformanceMetricsRequest.DateFrom,
45.             getPerformanceMetricsRequest.DateTo));
46.         return Results.Ok(performanceMetrics);
47.     }
48. 
49.     private static async Task<IResult> GetHealthMetrics(
50.         IMediator mediator,
51.         [FromRoute] Guid id,
52.         [AsParameters] GetHealthMetricsRequest getHealthMetricsRequest)
53.     {
54.         var healthMetrics = await mediator.Send(new GetHealthMetricsQuery(
55.             id,
56.             getHealthMetricsRequest.AthleteId,
57.             getHealthMetricsRequest.MetricType,
58.             getHealthMetricsRequest.DateFrom,
59.             getHealthMetricsRequest.DateTo));
60.         return Results.Ok(healthMetrics);
61.     }
62.     
63.     private static async Task<IResult> CreateSession(
64.         IMediator mediator,
65.         [FromBody] CreateSessionRequest createSessionRequest)
66.     {
67.         var session = await mediator.Send(new CreateSessionCommand(
68.             createSessionRequest.TeamId, 
69.             createSessionRequest.Duration));
70.         return Results.Ok(session);
71.     }
72. 
73.     private static async Task<IResult> CreatePerformanceMetric(
74.         IMediator mediator,
75.         [FromRoute] Guid id,
76.         [FromBody] CreatePerformanceMetricRequest createPerformanceMetricRequest)
77.     {
78.         await mediator.Send(new CreatePerformanceMetricCommand(
79.             id,
80.             createPerformanceMetricRequest.TeamAthleteId,
81.             createPerformanceMetricRequest.MetricType,
82.             createPerformanceMetricRequest.MetricValue));
83.         return Results.NoContent();
84.     }
85. 
86.     private static async Task<IResult> PopulatePerformanceMetrics(
87.         IMediator mediator,
88.         [FromRoute] Guid id,
89.         [FromBody] PopulatePerformanceMetricsRequest populatePerformanceMetricsRequest)
90.     {
91.         await mediator.Send(new PopulatePerformanceMetricsCommand(
92.             id,
93.             populatePerformanceMetricsRequest.TeamAthleteId,
94.             populatePerformanceMetricsRequest.Metrics));
95.         return Results.NoContent();
96.     }
97. 
98.     private static async Task<IResult> CreateHealthMetric(
99.         IMediator mediator,
100.         [FromRoute] Guid id,
101.         [FromBody] CreateHealthMetricRequest createHealthMetricRequest)
102.     {
103.         await mediator.Send(new CreateHealthMetricCommand(
104.             id,
105.             createHealthMetricRequest.TeamAthleteId,
106.             createHealthMetricRequest.MetricType,
107.             createHealthMetricRequest.MetricValue));
108.         return Results.NoContent();
109.     }
110. 
111.     private static async Task<IResult> PopulateHealthMetrics(
112.         IMediator mediator,
113.         [FromRoute] Guid id,
114.         [FromBody] PopulateHealthMetricsRequest populateHealthMetricsRequest)
115.     {
116.         await mediator.Send(new PopulateHealthMetricsCommand(
117.             id,
118.             populateHealthMetricsRequest.TeamAthleteId,
119.             populateHealthMetricsRequest.Metrics));
120.         return Results.NoContent();
121.     }
122.     
123.     private static async Task<IResult> DeleteSession(
124.         IMediator mediator,
125.         [FromRoute] Guid id)
126.     {
127.         await mediator.Send(new DeleteSessionCommand(id));
128.         return Results.NoContent();
129.     }
130. }

ДОДАТОК Д
session-item-component.ts

1. @Component({
2.   selector: 'app-session-item',
3.   templateUrl: './session-item.component.html',
4.   styleUrls: ['./session-item.component.scss']
5. })
6. export class SessionItemComponent implements OnInit {
7.   session!: Session;
8.   athletes: Athlete[] = [];
9.   displayedColumns: string[] = ["email", "firstName", "lastName"];
10.   userSelected: boolean = false;
11.   heartMetrics: Array<any> = [];
12.   speedMetrics: Array<any> = [];
13.   distanceMetrics: Array<any> = [];
14.   caloricBurnMetrics: Array<any> = [];
15.   exerciseDurationMetrics: Array<any> = [];
16. 
17.   constructor(
18.     private sessionService: SessionService,
19.     private teamService: TeamsService,
20.     private activatedRoute: ActivatedRoute,
21.     private router: Router
22.   ) { }
23. 
24.   ngOnInit(): void {
25.     this.activatedRoute.params.subscribe(x => {
26.       let id = x['id']
27.       this.getSessionById(id);
28.     });
29.   }
30. 
31.   getSessionById(id: string){
32.     this.sessionService.getSessionById(id).subscribe(x => {
33.       this.session = x;
34.       this.getTeamAthletes(this.session.teamId);
35.     })
36.   }
37. 
38.   deleteSession(){
39.     this.sessionService.deleteSession(this.session.id).subscribe(x => {
40.       this.router.navigateByUrl(`/teams/${this.session.teamId}`)
41.     })
42.   }
43. 
44.   getTeamAthletes(teamId: string){
45.     this.teamService.getAthletes(teamId).subscribe(x => {
46.       this.athletes = x;
47.     })
48.   }
49. 
50.   onSelectUser(athleteId: string){
51.     this.userSelected = true;
52. 
53.     this.sessionService.getHealthMetrics(this.session.id, athleteId, 'HeartRate').subscribe(x => {
54.       this.heartMetrics = x;
55.       var data = this.heartMetrics.map((val, index) => ({ "name": (index + 1).toString(), "value": val.metricValue }));
56.       this.heartRateData = [
57.         {
58.           "name": "Speed",
59.           "series": data
60.         }
61.       ]
62.     })
63. 
64.     this.sessionService.getPerformanceMetrics(this.session.id, athleteId, 'Speed').subscribe(x => {
65.       this.speedMetrics = x;
66.       var data = this.speedMetrics.map((val, index) => ({ "name": (index + 1).toString(), "value": val.metricValue }));
67.       this.speedData = [
68.         {
69.           "name": "Speed",
70.           "series": data
71.         }
72.       ]
73.     })
74. 
75.     this.sessionService.getPerformanceMetrics(this.session.id, athleteId, 'Distance').subscribe(x => {
76.       this.speedMetrics = x;
77.       var data = this.speedMetrics.map((val, index) => ({ "name": (index + 1).toString(), "value": val.metricValue }));
78.       this.speedData = data;
79.     })
80.   }
81. 
82.   view: [number, number] = [700, 400];
83.   centeredView: [number, number] = [700, 400];
84. 
85.   gradient = false;
86.   showLegend = true;
87.   showLabels = true;
88.   explodeSlices = false;
89.   doughnut = false;
90.   roundEdges = true;
91. 
92.   colorScheme: Color = {
93.     name: 'light',
94.     selectable: true,
95.     group: ScaleType.Ordinal,
96.     domain: ['#80CBC4', '#C5E1A5', '#FFF59D', '#FFCC80', '#FFAB91', '#BCAAA4']
97.   };
98. 
99.   heartRateData: any = [];
100.   distanceData: any = [];
101.   speedData: any = [];
102.   caloricBurnData = [];
103.   exerciseDurationData = [];
104. }

ДОДАТОК Е
REST API Специфікація

Шлях	Метод	Призначення
/api/databaseOperations/backup	POST	Бекап бази даних
/api/databaseOperations/restore	POST	Відновлення бази даних
/api/auth/login	POST	Вхід в акаунт
/api/auth/signup	POST	Створення акаунту
/api/users	GET	Отримання всіх користувачів
/api/users/{id}	GET	Отримання одного користувача
/api/sports	GET	Отримати всі спорти
/api/athletes	GET	Отримати всіх атлетів
/api/athletes/{id}	GET	Отримати одного атлету
/api/athletes	POST	Створення атлету
/api/teams	GET	Отримання всіх команд
/api/teams/{id}	GET	Отримання однієї команди
/api/teams	POST	Створення команди
/api/teams/{id}/athletes	POST	Додавання атлету до команди
/api/teams/{id}/athletes	DELETE	Видалення атлету з команди
/api/sessions	GET	Отримання сесії
/api/sessions/{id}/performanceMetrics	GET	Отримання метрик виконання за сесію
/api/sessions/{id}/healthMetrics	GET	Отримання метрик здоров'я за сесію
/api/sessions	POST	Створення сесії
/api/sessions/{id}/performanceMetrics	POST	Створення метрики
/api/sessions/{id}/healthMetrics	POST	Створення метрики
/api/sessions/{id}/performanceMetrics/batch	POST	Створення метрик
/api/sessions/{id}/healthMetrics/batch	POST	Створення метрик
/api/sessions/{id}	DELETE	Видалення сесії

ДОДАТОК Є
en.json

1. {
2.   "auth.login": "Log in",
3.   "auth.email": "Email",
4.   "auth.password": "Password",
5.   "auth.submit": "Submit",
6.   "auth.noAccountYet": "No Account Yet?",
7.   "auth.signup": "Sign up",
8.   "auth.firstName": "First Name",
9.   "auth.lastName": "Last Name",
10.   "auth.alreadyHaveAccount": "Already Have an Account?",
11.   "homepage.text": "System provides a cutting-edge solution for monitoring and analyzing the health and physical performance of athletes. By seamlessly collecting data from various devices and sensors, it offers an intuitive interface for coaches and other stakeholders. This enables informed decision-making regarding training programs and athlete development plans. With advanced analytical capabilities and integration with a wide range of devices, our system delivers a comprehensive view of athletes' physical condition, enhancing training efficiency and helping achieve exceptional results in sports competitions. ",
12.   "navbar.teams": "Teams",
13.   "navbar.users": "Users",
14.   "teams.createTeam": "Create Team",
15.   "teams.name": "Name",
16.   "teams.country": "Country",
17.   "teams.sport": "Sport",
18.   "teams.editTeam": "Edit",
19.   "teams.deleteTeam": "Delete",
20.   "teams.createSession": "Create Session",
21.   "teams.sessionDuration": "Duration in minutes",
22.   "teams.sessionDate": "Date",
23.   "teams.sessionEndDate": "End Date",
24.   "users.email": "Email",
25.   "users.firstName": "First Name",
26.   "users.lastName": "Last Name",
27.   "sessions.startDate": "Start Date",
28.   "sessions.endDate": "End Date",
29.   "sessions.duration": "Duration",
30.   "sessions.durationMinutes": "minutes",
31.   "sessions.deleteSession": "Delete",
32.   "sessions.heartRate": "Heart Rate",
33.   "sessions.distance": "Distance",
34.   "sessions.speed": "Speed",
35.   "sessions.caloricBurn": "Caloric Burn",
36.   "sessions.exerciseDuration": "Exercise Duration"
37. }

ДОДАТОК Ж
ua.json

1. {
2.   "auth.login": "Увійти",
3.   "auth.email": "Електронна пошта",
4.   "auth.password": "Пароль",
5.   "auth.submit": "Надіслати",
6.   "auth.noAccountYet": "Ще немає облікового запису?",
7.   "auth.signup": "Зареєструватися",
8.   "auth.firstName": "Ім'я",
9.   "auth.lastName": "Прізвище",
10.   "auth.alreadyHaveAccount": "Вже є обліковий запис?",
11.   "homepage.text": "Cистема надає передове рішення для моніторингу та аналізу здоров'я і фізичної підготовки спортсменів. Збираючи дані з різних пристроїв та сенсорів, вона пропонує інтуїтивний інтерфейс для тренерів та інших зацікавлених осіб. Це дозволяє приймати обґрунтовані рішення щодо тренувальних програм та планів розвитку спортсменів. За допомогою високорозвинутих аналітичних можливостей та інтеграції з широким спектром пристроїв, наша система надає комплексний погляд на фізичний стан спортсменів, покращуючи ефективність тренувань та допомагаючи досягати виняткових результатів у спортивних змаганнях.",
12.   "navbar.teams": "Команди",
13.   "navbar.users": "Користувачі",
14.   "teams.createTeam": "Створити команду",
15.   "teams.name": "Назва",
16.   "teams.country": "Країна",
17.   "teams.sport": "Вид спорту",
18.   "teams.editTeam": "Редагувати",
19.   "teams.deleteTeam": "Видалити",
20.   "teams.createSession": "Створити сеанс",
21.   "teams.sessionDuration": "Тривалість у хвилинах",
22.   "teams.sessionDate": "Дата",
23.   "teams.sessionEndDate": "Дата закінчення",
24.   "users.email": "Електронна пошта",
25.   "users.firstName": "Ім'я",
26.   "users.lastName": "Прізвище",
27.   "sessions.startDate": "Дата початку",
28.   "sessions.endDate": "Дата закінчення",
29.   "sessions.duration": "Тривалість",
30.   "sessions.durationMinutes": "хвилин",
31.   "sessions.deleteSession": "Видалити",
32.   "sessions.heartRate": "Пульс",
33.   "sessions.distance": "Відстань",
34.   "sessions.speed": "Швидкість",
35.   "sessions.caloricBurn": "Калорійний спалювання",
36.   "sessions.exerciseDuration": "Тривалість вправ"
37. }

ДОДАТОК З
JwtService.cs

1. public JwtSecurityToken GenerateToken(SigningCredentials signingCredentials,
2.         IEnumerable<Claim> claims)
3.     {
4.         var token = new JwtSecurityToken(
5.             issuer: _jwtOptions.Issuer,
6.             audience: _jwtOptions.Audience,
7.             claims: claims,
8.             expires: DateTime.Now.AddDays(30),
9.             signingCredentials: signingCredentials);
10. 
11.         return token;
12.     }

ДОДАТОК И
sketch.uno

1. #include <Wire.h>
2. #include <Adafruit_GFX.h>
3. #include <Adafruit_SSD1306.h>
4. 
5. #define SCREEN_WIDTH 128 // Ширина дисплея OLED (в пікселях)
6. #define SCREEN_HEIGHT 64 // Висота дисплея OLED (в пікселях)
7. 
8. // Оголошення дисплея SSD1306, підключеного до I2C (піни SDA, SCL)
9. Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
10. 
11. const int MPU_ADDRESS = 0x68; // Адреса MPU6050 по I2C
12. float AccX, AccY, AccZ;
13. float GyroX, GyroY, GyroZ;
14. float accAngleX, accAngleY, gyroAngleX, gyroAngleY, gyroAngleZ;
15. float roll, pitch, yaw;
16. float elapsedTime, currentTime, previousTime;
17. 
18. void setup() {
19.   Wire.begin();                      // Ініціалізація зв'язку
20.   Wire.beginTransmission(MPU_ADDRESS);       // Початок зв'язку з MPU6050
21.   Wire.write(0x6B);                  // Розмова з регістром 6B
22.   Wire.write(0x00);                  // Скидання - записуємо 0 в регістр 6B
23.   Wire.endTransmission(true);        // Завершення передачі
24.   delay(20);
25. 
26.   // SSD1306_SWITCHCAPVCC = генерування напруги дисплея з 3.3V внутрішньо
27.   if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
28.     for(;;);
29.   }
30.   display.display();
31.   delay(2000);
32.   display.clearDisplay();
33.   display.setTextSize(1);      // Звичайний масштаб 1:1 пікселів
34.   display.setTextColor(SSD1306_WHITE); // Білий колір тексту
35.   display.setCursor(0, 0);     // Початок в лівому верхньому куті
36. }
37. 
38. void loop() {
39.   // Зчитування даних з акселерометра
40.   Wire.beginTransmission(MPU_ADDRESS);
41.   Wire.write(0x3B); // Починаємо з регістра 0x3B (ACCEL_XOUT_H)
42.   Wire.endTransmission(false);
43.   Wire.requestFrom(MPU_ADDRESS, 6, true); // Зчитуємо 6 регістрів, значення кожної вісі зберігається в 2 регістрах
44. 
45.   AccX = (Wire.read() << 8 | Wire.read()) / 16384.0; // Значення по осі X
46.   AccY = (Wire.read() << 8 | Wire.read()) / 16384.0; // Значення по осі Y
47.   AccZ = (Wire.read() << 8 | Wire.read()) / 16384.0; // Значення по осі Z
48. 
49.   // Обчислення кутів нахилу за допомогою акселерометра
50.   accAngleX = (atan(AccY / sqrt(pow(AccX, 2) + pow(AccZ, 2))) * 180 / PI); 
51.   accAngleY = (atan(-1 * AccX / sqrt(pow(AccY, 2) + pow(AccZ, 2))) * 180 / PI); 
52. 
53.   // Зберігання попереднього часу перед зчитуванням поточного
54.   previousTime = currentTime;
55.   currentTime = millis(); // Зчитування поточного часу
56.   elapsedTime = (currentTime - previousTime) / 1000; // Перетворення мілісекунд в секунди
57. 
58.   // Зчитування даних з гіроскопа
59.   Wire.beginTransmission(MPU_ADDRESS);
60.   Wire.write(0x43); // Початок даних з гіроскопа - адреса першого регістра 0x43
61.   Wire.endTransmission(false);
62.   Wire.requestFrom(MPU_ADDRESS, 6, true); // Зчитуємо 6 регістрів, значення кожної вісі зберігається в 2 регістрах
63. 
64.   GyroX = (Wire.read() << 8 | Wire.read()) / 131.0; // Значення гіроскопа по осі X
65.   GyroY = (Wire.read() << 8 | Wire.read()) / 131.0; // Значення гіроскопа по осі Y
66.   GyroZ = (Wire.read() << 8 | Wire.read()) / 131.0; // Значення гіроскопа по осі Z
67. 
68.   // Оновлення кутів нахилу за допомогою гіроскопа
69.   gyroAngleX = gyroAngleX + GyroX * elapsedTime; // deg/s * s = deg
70.   gyroAngleY = gyroAngleY + GyroY * elapsedTime;
71.   yaw =  yaw + GyroZ * elapsedTime;
72. 
73.   // Об'єднання даних акселерометра та гіроскопа для отримання кінцевих значень кутів нахилу
74.   // Значення кутів нахилу обчислюються, приділяючи 96% ваги значенням гіроскопа та 4% - значенням акселерометра
75.   roll = 0.96 * gyroAngleX + 0.04 * accAngleX; // Кут нахилу в плоскості X
76.   pitch = 0.96 * gyroAngleY + 0.04 * accAngleY; // Кут нахилу в плоскості Y
77. 
78.   // Відображення значень на OLED дисплеї
79.   display.clearDisplay();
80. 
81.   display.setCursor(0, 0);
82.   display.print("Roll: ");
83.   display.print(roll);
84. 
85.   display.setCursor(0, 10);
86.   display.print("Pitch: ");
87.   display.print(pitch);
88. 
89.   display.setCursor(0, 20);
90.   display.print("Yaw: ");
91.   display.print(yaw);
92. 
93.   display.display();
94. 
95.   delay(100);
96. }
97.

ДОДАТОК І
PerformanceMetrics.sql

1. CREATE TABLE [dbo].[PerformanceMetrics]
2. (
3. 	[Id] UNIQUEIDENTIFIER NOT NULL PRIMARY KEY,
4. 	[SessionId] UNIQUEIDENTIFIER NOT NULL,
5. 	[TeamAthleteId] UNIQUEIDENTIFIER NOT NULL,
6. 	[MetricType] INT NOT NULL,
7. 	[MetricValue] DECIMAL NULL,
8. 	[TimeStamp] DATE,
9. 	CONSTRAINT	[FK_PerformanceMetrics_SessionId] FOREIGN KEY ([SessionId]) REFERENCES [dbo].[Sessions]([Id]),
10. 	CONSTRAINT	[FK_PerformanceMetrics_TeamAthleteId] FOREIGN KEY ([TeamAthleteId]) REFERENCES [dbo].[TeamAthletes]([Id])
11. )

ДОДАТОК Ї
DependencyRegistrar.cs

1. private static void ConfigureIdentity(
2.         this IServiceCollection services)
3.     {
4.         services.AddIdentity<User, Role>(opt => 
5.             {
6.                 opt.Password.RequiredLength = 8;
7.                 opt.Password.RequireLowercase = false;
8.                 opt.Password.RequireUppercase = true;
9.                 opt.Password.RequireDigit = true;
10.                 opt.Password.RequireNonAlphanumeric = false;
11.                 opt.User.RequireUniqueEmail = true;
12.                 opt.SignIn.RequireConfirmedEmail = false;
13.             })
14.             .AddDefaultTokenProviders()
15.             .AddEntityFrameworkStores<AppDbContext>();
16.     }

ДОДАТОК Й
DatabaseService.cs

1. public class DatabaseService: IDatabaseService
2. {
3.     private readonly IConfiguration _configuration;
4. 
5.     public DatabaseService(IConfiguration configuration)
6.     {
7.         _configuration = configuration;
8.     }
9. 
10.     public async Task BackupDatabaseAsync(
11.         BackupDatabaseDto backupDatabaseDto,
12.         CancellationToken cancellationToken = default)
13.     {
14.         var filePath = BuildBackupPathWithFilename(backupDatabaseDto);
15. 
16.         var connectionString = _configuration.GetConnectionString("SqlConnection");
17.         if (string.IsNullOrWhiteSpace(connectionString))
18.         {
19.             throw new ApplicationException("Connection string is null");
20.         }
21.         
22.         await using var connection = new SqlConnection(connectionString);
23.         var query = $"BACKUP DATABASE [{backupDatabaseDto.DatabaseName}] TO DISK='{filePath}'";
24. 
25.         await using var command = new SqlCommand(query, connection);
26.         await connection.OpenAsync(cancellationToken);
27.         await command.ExecuteNonQueryAsync(cancellationToken);
28.     }
29. 
30.     public async Task RestoreDatabaseAsync(
31.         RestoreDatabaseDto restoreDatabaseDto, 
32.         CancellationToken cancellationToken = default)
33.     {
34.         var connectionString = _configuration.GetConnectionString("SqlConnection");
35.         if (string.IsNullOrWhiteSpace(connectionString))
36.         {
37.             throw new ApplicationException("Connection string is null");
38.         }
39.         
40.         await using var connection = new SqlConnection(connectionString);
41.         
42.         await connection.OpenAsync(cancellationToken);
43.         
44.         try
45.         {
46.             var sql = @"
47.                         declare @database varchar(max) = quotename(@databaseName)
48.                         EXEC('ALTER DATABASE ' + @database + ' SET SINGLE_USER WITH ROLLBACK IMMEDIATE')";
49.             await using (var command = new SqlCommand(sql, connection))
50.             {
51.                 command.CommandType = CommandType.Text;
52.                 command.Parameters.AddWithValue("@databaseName", restoreDatabaseDto.DatabaseName);
53. 
54.                 await command.ExecuteNonQueryAsync(cancellationToken);
55.             }
56. 
57.             var dataPath = Path.Combine(restoreDatabaseDto.SqlServerBasePath, "DATA");
58.             var fileListDataPath = Path.Combine(dataPath, $"{restoreDatabaseDto.DatabaseName}.mdf");
59.             var fileListLogPath = Path.Combine(dataPath, "FileListLogName.ldf");
60. 
61.             sql = @"
62.                     RESTORE DATABASE @databaseName 
63.                     FROM DISK = @localDatabasePath 
64.                     WITH REPLACE,
65.                     MOVE @fileListDataName to @fileListDataPath,
66.                     MOVE @fileListLogName to @fileListLogPath";
67. 
68.             await using (var command = new SqlCommand(sql, connection))
69.             {
70.                 command.CommandTimeout = 7200;
71.                 command.CommandType = CommandType.Text;
72.                 command.Parameters.AddWithValue("@databaseName", "FileListLogName.ldf");
73.                 command.Parameters.AddWithValue("@localDatabasePath", restoreDatabaseDto.LocalDatabasePath);
74.                 command.Parameters.AddWithValue("@fileListDataName", "FileListDataName.ldf");
75.                 command.Parameters.AddWithValue("@fileListDataPath", fileListDataPath);
76.                 command.Parameters.AddWithValue("@fileListLogName", fileListLogPath);
77.                 command.Parameters.AddWithValue("@fileListLogPath", fileListLogPath);
78. 
79.                 await command.ExecuteNonQueryAsync(cancellationToken);
80.             }
81. 
82.             sql = @"
83.                         declare @database varchar(max) = quotename(@databaseName)
84.                         EXEC('ALTER DATABASE ' + @database + ' SET MULTI_USER')";
85.             await using (var command = new SqlCommand(sql, connection))
86.             {
87.                 command.CommandType = CommandType.Text;
88.                 command.Parameters.AddWithValue("@databaseName", restoreDatabaseDto.DatabaseName);
89. 
90.                 await command.ExecuteNonQueryAsync(cancellationToken);
91.             }
92.         }
93.         catch (Exception ex)
94.         {
95.             throw new ApplicationException("Exception occured during database backup: " + ex.Message);
96.         }
97.     }
98.     
99.     private static string BuildBackupPathWithFilename(BackupDatabaseDto backupDatabaseDto)
100.     {
101.         var filename = $"{backupDatabaseDto.DatabaseName}-{DateTime.Now:yyyy-MM-dd}.bak";
102. 
103.         return Path.Combine(backupDatabaseDto.FolderPath, filename);
104.     }
105. }
